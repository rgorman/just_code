---
title: "Variable extraction and Combination"
output: html_notebook
---


## Variable Extraction

This section extracts the @attributes from <word> elements of the XML treebank files.

Implement necessary R packages:

```{r}
require(XML) # Functions to handle XML
require(tidyverse) # Functions to simplify programming and handle data frames
require(stringr) # Functions to handle  character strings (i.e., texts)
```


***

#### Identify files to be processed and store file names and location.

```{r}
input.dir <- "./combin_input" # store target directory
files.v <- dir(path=input.dir, pattern=".*xml") # store file names as character vector
```
Notes:

* dir() produces a character vector of the file names in the specified location
* The parameter "path=" takes the directory location, here stored in "input.dir."
* The parameter "pattern=" uses a regular expression to match certain files names. In this case, ".*xml" will match all xml files. In regular expression syntax, the dot (".") matches any character, the asterisk is a quantifier that means "match the previous element zero or more times."

***
It is a good idea to check the contents of files.v to see that all are present and correct:

```{r}
files.v
```

***

#### Extract all attributes from treebank XML file and store in list object.

```{r}
# read xml structure from file to .R object
doc.object <- xmlTreeParse(file.path(input.dir, files.v[i]), useInternalNodes=TRUE)

# extract all <word> elements and children into XmlNodeList object
word.nodes <- getNodeSet(doc.object, "//word")


word.list <- xmlApply(word.nodes, xmlToList)

```
Notes:

* **xmlTreeParse()** converts and XML file to a format that can be manipulated by R.
* The **parameter "useInternalNodes=TRUE"** is necessary for proper processing. I don't know why.
* **xmlTreeParse()** requires the file path and name as input. These are supplied through **file.path(**), a function which pastes together its arguments with "/" as a separator. This is a convenience function. Notice that **file.v** is here subset with the index position indicated by an "i". This is an increment variable and is meant to be used within a loop when an entire directory is being processed.  The loop will be added later.
* **getNOdeSet()** identifies and collects nodes that match a particular criterion. Here the XQuery syntax "//word" is that criterion. This notation indicates that every word node in doc.object should be stored in word.nodes, a list object.
* **xmlApply()** is an iterator that operates on each element in word.nodes. **xmlToList()** is the function applied to each word element. The function returns a list, each of whose elements is a named character vector.  The names represent the attribute names of the word elements, the data represent the values of those attributes. **This step is useful because a list of character vectors is easier to work with than xml objects such as the contents of word.nodes.**

***

#### Extract the names of all attributes of the <word> elements so that they can be counted and also combined into new variables.

```{r}
y <- map(word.list, names) %>%
  unlist() %>%
  unique()

y <- y[-which(y == "insertion_id" | y == "artificial") ] # remove attributes associated only with ellipses.

```
Notes:

* **map()** is an iterator that applies a function to every element in a list or vector and returns a list. Here it applies the **names()** function to word.list.
* **%>%** is a pipe function that passes the results of the code to its left to the code following. It makes code easier to write and read since it is possible to avoid nesting of functions and their arguments.
* **unlist()** converts the output of names() to a character vector and **unique()** eliminates duplicates.
* **insertion_id** and **artificial** are removed from the vector of attributes, since they only occur with ellipses and contain no additional syntactic information. **Failure to remove these attributes will break subsequent code.**


As of 10-9-17, each word element has the following attributes (values may often be "NA" or "null"):

* Attributes 1-6: the original treebank attributes (e.g., @id, @form, @lemma, etc.); these are not used for directly for syntactic analysis.
* 7:. **cite.** This attribute contains human readable meta data on author, text, etc. These data should be kept associated with other variables to provide the ability to isolate words for analysis and for identifying trouble with the code.
* 8: **Subtree.** This attribute contains the id numbers of those nodes which form the graph-theoretical "subtree" of a given node. The subtree is made up of the node itself and all nodes depending **directly or indirectly** upon it. This attribute is not used directly in syntactic analysis (because it is a sequence of integers without inherent syntactic meaning).
* 9-10: **Projectivity and Planarity.** These attributes give information about the relationship between the subtree of a node and the word order of those nodes. It will be used for syntactic analysis, but its value for that purpose is still unknown.
* 11: **DepDist.** This attributes records the distance (in the linear order of words) between each node and its parent node. The value may be "NA" for nodes dependent on the root or nodes dependent on ellipses. This attribute is not used directly in syntactic analysis, but it is the basis of other attributes and variables.
* 12: **Neighborhood.** This attribute contains the id numbers of those nodes which form the graph-theoretical "neighborhood" of a given node. The neighborhood is made up of the node itself and all nodes depending **directly**  upon it. This attribute is not used directly in syntactic analysis (because it is a sequence of integers without inherent syntactic meaning).
* 13-15: **Relation_Subtree, POS_Subtree, and Rel_Pos_Subtree.** These (somewhat mis-named) attributes contain syntactic information on the nodes in the neighborhood of the target node. Respectively, they record the syntactic relation, the part-of-speech, and the combination of relation and part-of-speech for every node in the neighborhood. The data values of these attributes also preserve the word order of the nodes in a neighborhood. They will be used in syntactic analysis, but their value for that purpose is still unknown.
* 16: **self-relation.** This attribute simply records the value in the "relation" attribute of the original treebank XML file. It adds the prefix "self-" so that names of the new variables containing this variable will be easier to read and understand. It will be used in syntactic analysis.
* 17: **self-depdist.** A modification of "DepDist" analogous to "self-relation." It will be used in syntactic analysis.
* 18-26: **Morphological attributes.** These attributes are human-readable names corresponding to the nine morphological categories recorded in the treebank "postag" attribute. Values for these attributes may be "NA". These attributes will be used for syntactic analysis.
* 27-39: **parent- attributes.** These attributes contain the same kind of information as do attributes 9, 10, and 16-26, but for the parent of the target node. They are identified by the prefix "parent-." They may contain values of "NA" and "null." These attributes will be used for syntactic analysis.
* 40-52: **g1-parent attributes.** Again, these attributes parallel 9, 10, and 16-26, but with data for the parent of the parent of the target node. The values for a good many of these attributes will be "NA" and especially "null," since many nodes will not have a grand-parent. These attributes will be used for syntactic analysis. 
* 53-55: **g2-parent attributes.** These attributes give the relation, part-of-speech, and dependency distance for the "great-grand-parent" of the target node. They will be used for syntactic analysis. In particular, they will form a part of the recreation of the "sWord levels" variables of previous analyses.
* 56-58: **g3-parent attributes.** Analogous to 53-55, but for the "previous generation" of ancestor. These will be used for syntactic analysis.
* 59-61: **g4-parent attributes.** Analogous to 56-58, but for the "previous generation" of ancestor. These will be used for syntactic analysis.

***

#### Create a data frame containg the values for each attribute of each word element.


```{r}
for (i in seq_along(y)) {
  
  if ( i == 1) {
    
    z <- word.list %>% map_chr(y[i]) %>%
      data.frame(check.names = FALSE, stringsAsFactors = FALSE)
    
  } else {
    
    z <- word.list %>% map_chr(y[i]) %>%
      cbind(z,  ., stringsAsFactors = FALSE)
    
  }
}

colnames(z) <- y # name the columns according with the attribute names

```

Notes:

* The for loop iterates along each element in the vector "y". These elements are then names of the attributes.
* The if/else switch first creates a data frame with the first attribute as a column, then binds all additional attributes to it as additional columns.
* **word.list %>% map_chr(y[i])** feeds each the contents of the list "word.list" into the map_chr() function.  This function extracts the value for the named item in the character vector. The name is given by the incremental variable used to subset "y" (i.e., **y[i]**), which is the argument to map_chr(). map.chr() returns a character vector.
* **data.frame() and cbind()** together produce a data frame in which each row represents a word from the XML file and each column represents an attribute. All values are character vectors.
